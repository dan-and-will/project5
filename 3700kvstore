#!/usr/bin/python

import sys, socket, select, time, json, random

LEADER = 1
CANDIDATE = 2
FOLLOWER = 3

class LogEntry:

    def __init__(self, key, value, term):
        self.key = key
        self.value = value
        self.term = int(term)

    def __str__(self):
        return "{key}:{value}:{term}".format(key=self.key, value=self.value, term=self.term)

    @classmethod
    def parse(cls, entry):
        return cls(*entry.split(':'))

class KVstore:

    def __init__(self, my_id, replica_ids):
        self.id = my_id
        self.term = 1
        self.set_state(FOLLOWER)
        self.last_leader_hb = time.time()
        self.replicas = replica_ids
        self.quorum = (len(self.replicas) + 1) / 2 + 1
        self.log = [LogEntry('*', '*', 0)]
        self.commit_index = 0
        self.state_machine = {}
        self.replica_append_indices = {rep_id: 0 for rep_id in self.replicas}
        self.replica_commit_indices = {rep_id: 0 for rep_id in self.replicas}
        self.puts = {}

        # Connect to the network. All messages to/from other replicas and clients will
        # occur over this socket
        self.sock = socket.socket(socket.AF_UNIX, socket.SOCK_SEQPACKET)
        self.sock.connect(my_id)

    def set_state(self, state):
        self.state = state
        self.voted_for = None
        if self.state == FOLLOWER:
            self.timeout = random.randint(100, 250) / 1000.0
            self.last_leader_hb = time.time()
            self.leader = 'FFFF'
        elif self.state == CANDIDATE:
            self.votes = 1
            self.timeout = random.randint(100, 250) / 1000.0
            self.leader = 'FFFF'
        elif self.state == LEADER:
            self.leader = self.id
            self.timeout = 0.25
            self.RPC_sent = 0

    def send_append_entries(self): #data=None, index=None, term=None):
        for replica, prev_index in self.replica_append_indices.iteritems():
            prev_term = self.log[prev_index].term
            msg = json.dumps({'src': self.id,
                              'dst': replica,
                              'leader': self.id,
                              'type': 'append_entries',
                              'term': self.term,
                              'prev_index': prev_index,
                              'prev_term': prev_term,
                              'entries': [str(e) for e in self.log[prev_index + 1:]],
                              'commit': self.commit_index
                              })
            self.sock.send(msg)
            # print msg
        self.RPC_sent = time.time()

    def send_append_result(self, result, append_index):
        msg = json.dumps({'src': self.id,
                          'dst': self.leader,
                          'leader': self.leader,
                          'type': 'append_result',
                          'result': result,
                          'term': self.term,
                          'append_index': append_index,
                          'commit_index': self.commit_index
                          })
        # print msg
        self.sock.send(msg)

    def send_vote_request(self):
        msg = json.dumps({'src': self.id,
                          'dst': 'FFFF',
                          'leader': self.leader,
                          'type': 'vote_request',
                          'term': self.term,
                          'lastLogIndex': len(self.log) - 1,
                          'lastLogTerm': self.log[-1].term
                          })
        self.sock.send(msg)

    def cast_vote(self, candidate_id, result):
        self.voted_for = candidate_id
        msg = json.dumps({'src': self.id,
                          'dst': candidate_id,
                          'leader': 'FFFF',
                          'type': 'vote',
                          'result': result
                          })
        self.sock.send(msg)

    def redirect(self, client_msg):
        msg = json.dumps({'src': self.id,
                          'dst': client_msg['src'],
                          'leader': self.leader,
                          'type': 'redirect',
                          'MID': client_msg['MID']
                          })
        self.sock.send(msg)

    def commit(self, index):
        if self.state == FOLLOWER:
            pass #print len(self.log), self.commit_index, index
        for entry in self.log[self.commit_index + 1:index + 1]:
            if self.state == FOLLOWER:
                pass #print entry
            self.state_machine[entry.key] = entry.value
        self.commit_index = index
        # if index < 0:
        #     print 'State: {s}'.format(s=self.state)

    def respond_to_puts(self, commit_index):
        for index, put in self.puts.items():
            if index <= commit_index:
                msg = json.dumps({'src': self.id, 'dst': put[1], 'leader': self.id, 'type': 'ok', 'MID': put[0]})
                self.sock.send(msg)
                # print msg
                del self.puts[index]

    def start_election(self):
        self.voted_for = self.id
        self.term += 1
        self.set_state(CANDIDATE)
        self.election_start = time.time()
        self.send_vote_request()

    def handle_msg(self, msg):
        msg_type = msg['type']
        if self.state == FOLLOWER:
            if msg_type in ( 'put',):
                self.redirect(msg)
            elif msg_type == 'vote_request':
                if self.term <= msg['term']:
                    if self.voted_for is None or self.voted_for == msg['src']:
                        if len(self.log) -1 <= msg['lastLogIndex'] and self.log[-1].term <= msg['lastLogTerm']:
                            self.cast_vote(msg['src'], True)
                        else:
                            self.cast_vote(msg['src'], False)

            elif msg_type == 'append_entries':
                #TODO: check if should be leader
                self.last_leader_hb = time.time()
                self.leader = msg['src']
                if self.term < msg['term']:
                    self.term = msg['term']
                prev_index = msg['prev_index']
                prev_term = msg['prev_term']
                #follower's log is the same length as the leader's and has same previous entry
                if len(self.log) - 1 == prev_index and self.log[prev_index].term == prev_term:
                    #update log
                    self.log.extend([LogEntry.parse(e) for e in msg['entries']])
                    self.commit(msg['commit'])
                    self.send_append_result(True, len(self.log) - 1)
                else:
                    # print str(len(self.log)) + ".." + str(prev_index) + "\n" + \
                    # str([str(e) for e in self.log]) + "\n\n" + str(msg['entries']) + "\n\n\n\n\n"
                    self.send_append_result(False, len(self.log) - 1)

        elif self.state == CANDIDATE:
            if msg_type == 'vote':
                if msg['result']:
                    self.votes += 1
                    if self.votes >= self.quorum:
                        self.set_state(LEADER)
                else:
                    #TODO count quarum of no votes
                    pass
            elif msg_type == 'append_entries':
                if msg['term'] >= self.term:
                    self.set_state(FOLLOWER)
                    self.leader = msg['src']
                else:
                    #TODO reject...return false?
                    pass

        elif self.state == LEADER:
            if msg_type == 'get':
                val = self.state_machine[msg['key']]
                msg = json.dumps({'src': self.id, 'dst': msg['src'], 'leader': self.id, 'type': 'ok', 'MID': msg['MID'], 'value': val})
                self.sock.send(msg)
            elif msg_type == 'put':
                # if msg['key'] in self.state_machine:
                    # print 'DUUUUPE: {k}, {v0}, {v1}'.format(k=msg['key'], v0=self.state_machine[msg['key']], v1=msg['value'])
                self.puts[len(self.log)] = (msg['MID'], msg['src'])
                self.log.append(LogEntry(msg['key'], msg['value'], self.term))
                self.send_append_entries()
            elif msg_type == 'vote_request':
                if self.voted_for is None and msg['term'] > self.term:
                    self.cast_vote(msg['src'], True)
                else:
                    self.cast_vote(msg['src'], False)
            elif msg_type == 'append_entries':
                if self.term < msg['term']:
                    self.term = msg['term']
                    self.set_state(FOLLOWER)
                    self.leader = msg['src']
            elif msg_type == 'append_result':
                self.replica_append_indices[msg['src']] = msg['append_index']
                self.replica_commit_indices[msg['src']] = msg['commit_index']
                # print self.replica_append_indices

    def run(self):
        while True:
            ready = select.select([self.sock], [], [], 0.1)[0]
            if ready:
                msg_raw = self.sock.recv(32768)
                if len(msg_raw) > 0:
                    msg = json.loads(msg_raw)
                    self.handle_msg(msg)

            to = time.time() - self.timeout
            if self.state == FOLLOWER:
                if to >= self.last_leader_hb:
                    if self.voted_for is None:
                        self.start_election()

            elif self.state == CANDIDATE:
                if to >= self.election_start:
                    self.start_election()

            elif self.state == LEADER:
                if to >= self.RPC_sent:
                    self.send_append_entries()
                # 2nd largest logged index means 2 followers and leader have log entry
                quarum_append_index = sorted(self.replica_append_indices.values())[2]
                quarum_commit_index = sorted(self.replica_commit_indices.values())[2]
                # print quarum_append_index
                self.commit(quarum_append_index)
                self.respond_to_puts(quarum_append_index)

if __name__ == '__main__':
    # Your ID number
    my_id = sys.argv[1]
    # The ID numbers of all the other replicas
    replica_ids = sys.argv[2:]
    kvs = KVstore(my_id, replica_ids)
    kvs.run()
