#!/usr/bin/env python

import sys, socket, select, time, json, random

LEADER = 1
CANDIDATE = 2
FOLLOWER = 3

class LogEntry:

    def __init__(self, key, value, term):
        self.key = key
        self.value = value
        self.term = int(term)

    def __str__(self):
        return "{key}:{value}:{term}".format(key=self.key, value=self.value, term=self.term)

    def parse(entry):
        return LogEntry(*entry.split(':'))

class KVstore:

    def __init__(self, my_id, replica_ids):
        self.id = my_id
        self.term = 1
        self.set_state(FOLLOWER)
        self.last_leader_hb = time.time()
        self.replicas = replica_ids
        self.quorum = (len(self.replicas) + 1) / 2 + 1
        self.log = [LogEntry('*', '*', 0)]
        self.commit_index = 0
        self.state_machine = {}
        self.replica_indices = {rep_id: 0 for rep_id in self.replicas}

        # Connect to the network. All messages to/from other replicas and clients will
        # occur over this socket
        self.sock = socket.socket(socket.AF_UNIX, socket.SOCK_SEQPACKET)
        self.sock.connect(my_id)

    def set_state(self, state):
        self.state = state
        self.voted_for = None
        if self.state == FOLLOWER:
            self.timeout = random.randint(300, 500) / 1000.0
            self.last_leader_hb = time.time()
            self.leader = 'FFFF'
        elif self.state == CANDIDATE:
            self.votes = 0
            self.timeout = 0.3
            self.leader = 'FFFF'
            self.election_start = time.time()
        elif self.state == LEADER:
            self.leader = self.id
            self.timeout = 0.25
            self.RPC_sent = 0

    def apply_log_entry(self, index=None):
        if index is None:
            index = -1 # last element
        entry = self.log[index]
        self.state_machine[entry.key] = entry.value

    def send_append_entries(self, prev_index=None): #data=None, index=None, term=None):
        if prev_index is None:
            prev_index = len(self.log) - 1
        prev_term = self.log[prev_index].term
        msg = json.dumps({'src': self.id,
                          'dst': 'FFFF',
                          'leader': self.id,
                          'type': 'append_entries',
                          'term': self.term,
                          'prev_index': prev_index,
                          'prev_term': prev_term,
                          'entries': [str(e) for e in self.log[prev_index + 1:]],
                          'commit': self.commit_index
                          })
        self.sock.send(msg)
        self.RPC_sent = time.time()

    def send_append_success(self, term, index):
        msg = json.dumps({'src': self.id,
                          'dst': self.leader,
                          'leader': self.leader,
                          'type': 'append_success',
                          'term': term,
                          'index': index
                          })
        self.sock.send(msg)

    def send_append_fail(self, term, index):
        msg = json.dumps({'src': self.id,
                          'dst': self.leader,
                          'leader': self.leader,
                          'type': 'append_fail',
                          'term': term,
                          'index': index
                          })
        self.sock.send(msg)

    def send_vote_request(self):
        msg = json.dumps({'src': self.id,
                          'dst': 'FFFF',
                          'leader': self.leader,
                          'type': 'vote_request',
                          'term': self.term,
                          'lastLogIndex': len(self.log) - 1,
                          'lastLogTerm': self.log[-1].term
                          })
        self.sock.send(msg)

    def cast_vote(self, candidate_id, result):
        self.voted_for = candidate_id
        msg = json.dumps({'src': self.id,
                          'dst': candidate_id,
                          'leader': 'FFFF',
                          'type': 'vote',
                          'result': result
                          })
        self.sock.send(msg)

    def redirect(self, client_msg):
        msg = json.dumps({'src': self.id,
                          'dst': client_msg['src'],
                          'leader': self.leader,
                          'type': 'redirect',
                          'MID': client_msg['MID']
                          })
        self.sock.send(msg)

    def commit(self, index):
        for entry in self.log[self.commit_index + 1:index + 1]:
            self.state_machine[entry.key] = entry.value
        self.commit_index = index

    def start_election(self):
        self.voted_for = self.id
        self.term += 1
        self.set_state(CANDIDATE)
        self.send_vote_request()

    def update_log(self, entries):
        for entry in entries:
            key, val, idx = entry.split(":")
            new_entry = LogEntry(key, val, idx)


    def handle_msg(self, msg):
        msg_type = msg['type']
        if self.state == FOLLOWER:
            if msg_type in ('get', 'put',):
                self.redirect(msg)
            elif msg_type == 'vote_request':
                if self.term <= msg['term']:
                    if self.voted_for is None or self.voted_for == msg['src']:
                        if len(self.log) -1 <= msg['lastLogIndex'] and self.log[-1].term <= msg['lastLogTerm']:
                            self.cast_vote(msg['src'], True)
                        else:
                            self.cast_vote(msg['src'], False)

            elif msg_type == 'append_entries':
                self.last_leader_hb = time.time()
                self.leader = msg['src']
                if self.term < msg['term']:
                    self.term = msg['term']
                prev_index = msg['prev_index']
                prev_term = msg['prev_term']
                if len(self.log) - 1 == prev_index: #follower's log is the same length as the leaders....
                    if self.log[prev_index].term == prev_term:
                        #update log
                        self.log.extend(msg['entries'])
                        self.commit(msg['commit'])
                        self.send_append_success(self.term, len(self.log) - 1)
                else:
                    commit_entry = self.log[self.commit_index]
                    self.send_append_fail(commit_entry.term, self.commit_index)

        elif self.state == CANDIDATE:
            if msg_type == 'vote':
                if msg['result']
                    self.votes += 1
                    if self.votes + 1 >= self.quorum:
                        self.set_state(LEADER)
                else:
                    #TODO count quarum of no votes
                    pass
            elif msg_type == 'append_entries':
                if msg['term'] > self.term:
                    self.set_state(FOLLOWER)
                    self.leader = msg['src']

        elif self.state == LEADER:
            if msg_type == 'get':
                try:
                    val = self.state_machine[msg['key']]
                    msg = json.dumps({'src': self.id, 'dst': msg['src'], 'leader': self.id, 'type': 'ok', 'MID': msg['MID'], 'value': val})
                except:
                    msg = json.dumps({'src': self.id, 'dst': msg['src'], 'leader': self.id, 'type': 'fail', 'MID': msg['MID']})
                self.sock.send(msg)
            elif msg_type == 'put':
                try:
                    # self.state_machine[msg['key']] = msg['value']
                    self.append_log_entry(msg['key'], msg['value'])
                    # self.apply_log_entry()
                    msg = json.dumps({'src': self.id, 'dst': msg['src'], 'leader': self.id, 'type': 'ok', 'MID': msg['MID']})
                except:
                    msg = json.dumps({'src': self.id, 'dst': msg['src'], 'leader': self.id, 'type': 'fail', 'MID': msg['MID']})
                self.sock.send(msg)
            elif msg_type == 'vote_request':
                if self.voted_for is None and msg['term'] > self.term:
                    self.cast_vote(msg['src'], True)
                else:
                    self.cast_vote(msg['src'], False)
            elif msg_type == 'append_entries':
                if self.term < msg['term']:
                    self.term = msg['term']
                    self.set_state(FOLLOWER)
                    self.leader = msg['src']
            elif msg_type == "append_success":
                self.replica_indices[msg['src']] = msg['index']
            elif msg_type == "append_fail":
                if self.term < msg["term"]:
                    self.term = msg["term"]
                self.send_append_entries(msg['index'] + 1)

    def run(self):
        while True:
            ready = select.select([self.sock], [], [], 0.1)[0]
            if ready:
                msg_raw = self.sock.recv(32768)
                if len(msg_raw) > 0:
                    msg = json.loads(msg_raw)
                    self.handle_msg(msg)

            to = time.time() - self.timeout
            if self.state == FOLLOWER:
                if to >= self.last_leader_hb:
                    if self.voted_for is None:
                        self.start_election()

            elif self.state == CANDIDATE:
                if to >= self.election_start:
                    self.start_election()

            elif self.state == LEADER:
                if to >= self.RPC_sent:
                    self.send_append_entries()

if __name__ == '__main__':
    # Your ID number
    my_id = sys.argv[1]
    # The ID numbers of all the other replicas
    replica_ids = sys.argv[2:]
    kvs = KVstore(my_id, replica_ids)
    kvs.run()
